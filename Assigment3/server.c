/**
*Author: Junchen Su
*Purpose: Operating System Assigment3
*Date: 3/24/2017
*/
#include <stdlib.h>
#include <sys/types.h>
#include <stdio.h>
#include <netinet/in.h>
#include <string.h>
#include <signal.h>
#include <arpa/inet.h> 
#include <sys/socket.h>
#include <unistd.h>

#define BUFSIZ 1024

int totalLines = 0;                  
int totalDigits = 0;          
void checkStatus(int sig){   //functions to run when ctrl+c
    printf("Total input lines:%d \n",totalLines);
    printf("Total input digist:%d \r\n",totalDigits);
    exit(0);
}

int main(){
    FILE *secret;	//output file
    int slisten,sclient; //server file descriptor
    struct sockaddr_in s_add,c_add;	//socket address
    char buffer[BUFSIZ + 1];   	//used to store input from client socket
    int inputSize;			
    signal(SIGINT,checkStatus);//(Signal Interrupt) Interactive attention signal. Generally generated by the application user
    slisten = socket(AF_INET, SOCK_STREAM, 0);	//create a socket to listen
    if(-1 == slisten)
    {
        printf("socket creation fail ! \r\n");
        return -1;
    }

    //Socket API defines a generic data type for addresses, sockaddr_in is for TCP/IP
    s_add.sin_family = AF_INET;			//IPV4
    s_add.sin_addr.s_addr = inet_addr("192.168.0.11");	//set IP addr, use same IP so we can test on one laptop
    s_add.sin_port = htons(9008);			//set port number

    if(bind(slisten,(struct sockaddr *)(&s_add), sizeof(struct sockaddr)) == -1)//sockaddr_in can be casted to a sockaddr
    {
        printf("bind fail !\r\n");
        return -1;
    }

    if(listen(slisten,8) == -1)	//int status = listen(sockid, queueLimit), queuelimit: integer, # of active participants that can “wait” for a connection
    {
        printf("listen fail !\r\n");
        return -1;
    }
    //The listenning socket is never used for sending and receiving,
    //is used by the server only as a way to get new sockets

    while(1)
    {
        int i = 0, count = 0;
        unsigned int clientLen = sizeof(struct sockaddr_in);
        sclient = accept(slisten, (struct sockaddr *)(&c_add), &clientLen);	
        //accept a connection, create a new socket representing the connection with client, can be regarded as
        // a client socket descrptor, which contains client's IP/port info.
        //the input info. is stored in cfd by write(cfd,input,strlen(input));
        /*
        int s = accept(sockid, &clientAddr, &addrLen);
        s: integer, the new socket (used for data-transfer)
        sockid: integer, the orig. socket (being listened on)
        clientAddr: struct sockaddr, address of the active participant
        addrLen: sizeof(clientAddr): value/result parameter
        */
        if(sclient == -1)
        {
                printf("accept fail !\n");
                return -1;
        }
        printf("Server got connection from IP address: %#x, and port number: %#x\n",ntohl(c_add.sin_addr.s_addr),ntohs(c_add.sin_port));//ntohl: convert netork to host long
        
        if((inputSize = read(sclient,buffer,BUFSIZ)) == -1)	//read the input from nfd(cfd), put the context in buffer, return the digits read
        {
                printf("read fail !\n");
                return -1;
        }

        while(i<strlen(buffer)) {
                if(buffer[i] >= '0' && buffer[i] <= '9') {
                    count++;
                }
                i++;
        }
        buffer[inputSize] = '\0';
        printf("The input is %s, it has %d digits.\n",buffer,count);
        totalLines++;
        totalDigits += count;
        secret = fopen("secret.out","w");
        fprintf(secret, "The input is: %s the digits of this input is: %d\n",buffer,count);
        fclose(secret);
        close(sclient);
    }
    close(slisten);
    
    return 0;
}
